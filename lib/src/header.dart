import 'dart:io';

/// Represents a parsed script header with dependencies and configuration
class ScriptHeader {
  final Map<String, String> dependencies;
  final String? sdkConstraint;
  final String? pubspecYaml;
  final bool isFullManifest;

  ScriptHeader({
    required this.dependencies,
    this.sdkConstraint,
    this.pubspecYaml,
    required this.isFullManifest,
  });

  /// Generates a complete pubspec.yaml content
  String generatePubspecYaml() {
    if (isFullManifest && pubspecYaml != null) {
      return pubspecYaml!;
    }

    final buffer = StringBuffer();
    buffer.writeln('name: drun_script');
    buffer.writeln('description: Generated by drun');
    buffer.writeln('environment:');
    buffer.writeln('  sdk: "${sdkConstraint ?? '>=3.5.0 <4.0.0'}"');
    
    if (dependencies.isNotEmpty) {
      buffer.writeln('dependencies:');
      for (final entry in dependencies.entries) {
        buffer.writeln('  ${entry.key}: ${entry.value}');
      }
    }
    
    return buffer.toString();
  }
}

/// Parser for script headers that extracts dependency information
class HeaderParser {
  static const int _maxHeaderLines = 200;
  
  /// Parse the header of a Dart script file
  static ScriptHeader parseScript(String scriptPath) {
    final lines = _readHeaderLines(scriptPath);
    return _parseLines(lines);
  }
  
  /// Parse header from a list of lines
  static ScriptHeader parseLines(List<String> lines) {
    return _parseLines(lines);
  }
  
  static List<String> _readHeaderLines(String scriptPath) {
    final file = File(scriptPath);
    if (!file.existsSync()) {
      throw ArgumentError('Script file not found: $scriptPath');
    }
    
    final lines = file.readAsLinesSync();
    return lines.take(_maxHeaderLines).toList();
  }
  
  static ScriptHeader _parseLines(List<String> lines) {
    String? sdkConstraint;
    Map<String, String> dependencies = {};
    
    // Look for pubspec block first
    final pubspecBlock = _extractPubspecBlock(lines);
    if (pubspecBlock != null) {
      return ScriptHeader(
        dependencies: {},
        pubspecYaml: pubspecBlock,
        isFullManifest: true,
      );
    }
    
    // Otherwise, parse inline dependencies
    for (final line in lines) {
      final trimmed = line.trim();
      
      // Stop at first non-comment line (excluding shebang)
      if (!trimmed.startsWith('//') && !trimmed.startsWith('#!') && trimmed.isNotEmpty) {
        break;
      }
      
      if (trimmed.startsWith('//! dart-deps:')) {
        dependencies.addAll(_parseInlineDeps(trimmed));
      } else if (trimmed.startsWith('//! dart-sdk:')) {
        sdkConstraint = _parseSdkConstraint(trimmed);
      }
    }
    
    return ScriptHeader(
      dependencies: dependencies,
      sdkConstraint: sdkConstraint,
      isFullManifest: false,
    );
  }
  
  static String? _extractPubspecBlock(List<String> lines) {
    bool inBlock = false;
    bool foundContent = false;
    final buffer = StringBuffer();
    
    for (final line in lines) {
      final trimmed = line.trim();
      
      if (trimmed.startsWith('//! pubspec:')) {
        inBlock = true;
        continue;
      }
      
      if (inBlock) {
        if (trimmed.startsWith('///')) {
          // Remove the /// prefix but preserve indentation
          final content = trimmed.substring(3);
          // Remove only a single leading space if present (after ///)  
          final finalContent = content.startsWith(' ') ? content.substring(1) : content;
          
          // Empty line (just ///) ends the pubspec block if we've already found content
          if (finalContent.trim().isEmpty && foundContent) {
            break;
          }
          
          // Skip leading empty lines before content starts
          if (finalContent.trim().isEmpty && !foundContent) {
            continue;
          }
          
          foundContent = true;
          buffer.writeln(finalContent);
        } else if (trimmed.startsWith('//!')) {
          // Another directive - this could be an end marker or just another comment
          // End the pubspec block
          break;
        } else if (!trimmed.startsWith('//') && trimmed.isNotEmpty) {
          // Non-comment line ends the block
          break;
        } else if (trimmed.isEmpty && foundContent) {
          // Blank line (no comment) ends the block
          break;
        }
      }
    }
    
    final result = buffer.toString().trim();
    return result.isEmpty ? null : result;
  }
  
  static Map<String, String> _parseInlineDeps(String line) {
    final colonIndex = line.indexOf('dart-deps:');
    if (colonIndex < 0) return {};
    
    final raw = line.substring(colonIndex + 'dart-deps:'.length).trim();
    final deps = <String, String>{};
    
    // Split by comma, but respect quoted strings
    final parts = _splitRespectingQuotes(raw, ',');
    
    for (final part in parts) {
      final trimmed = part.trim();
      if (trimmed.isEmpty) continue;
      
      final equalsIndex = trimmed.indexOf('=');
      if (equalsIndex < 0) continue;
      
      final name = trimmed.substring(0, equalsIndex).trim();
      var value = trimmed.substring(equalsIndex + 1).trim();
      
      // Remove quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.substring(1, value.length - 1);
      }
      
      deps[name] = value;
    }
    
    return deps;
  }
  
  static String? _parseSdkConstraint(String line) {
    final colonIndex = line.indexOf('dart-sdk:');
    if (colonIndex < 0) return null;
    
    var constraint = line.substring(colonIndex + 'dart-sdk:'.length).trim();
    
    // Remove quotes if present
    if ((constraint.startsWith('"') && constraint.endsWith('"')) ||
        (constraint.startsWith("'") && constraint.endsWith("'"))) {
      constraint = constraint.substring(1, constraint.length - 1);
    }
    
    return constraint.isEmpty ? null : constraint;
  }
  
  static List<String> _splitRespectingQuotes(String input, String delimiter) {
    final result = <String>[];
    final buffer = StringBuffer();
    bool inQuotes = false;
    String? quoteChar;
    
    for (int i = 0; i < input.length; i++) {
      final char = input[i];
      
      if (!inQuotes && (char == '"' || char == "'")) {
        inQuotes = true;
        quoteChar = char;
        buffer.write(char);
      } else if (inQuotes && char == quoteChar) {
        inQuotes = false;
        quoteChar = null;
        buffer.write(char);
      } else if (!inQuotes && char == delimiter) {
        result.add(buffer.toString());
        buffer.clear();
      } else {
        buffer.write(char);
      }
    }
    
    if (buffer.isNotEmpty) {
      result.add(buffer.toString());
    }
    
    return result;
  }
}